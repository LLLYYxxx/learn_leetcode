交换排序
====================

1、冒泡排序

原理：在待排序列中对其中所有数，进行相邻两个的比较调整，使较大数下沉，较小数上冒。每趟比较完成后，不需要再调整排好顺序的元素。
过程：首先将第一个记录关键字和第二个记录的关键字进行比较，若为逆序，则将两个记录交换，然后第二个记录和第三个记录关键字。

如图
    
![image](https://github.com/LLLYYxxx/learn_leetcode/blob/main/常见排序——交换排序/material1.png)

代码：

     void BubbleSort(int a[],int n)
     {
         for(int i=0;i<n-1;++i)
         {
             for(int j=0;j<n-i-1;++j)//限制每趟比较次数
             {  
                  if(a[j]>a[j+1])
                  {
                      int temp=a[j];
                      a[j]=a[j+1];
                      a[j+1]=temp;
                  }
             }  
         }
     }
     
   
2、快速排序

原理：通过一趟排序将待排记录分割成独立的两个部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

    过程：              pivotkey=49
      初始关键字   （49，38，65，97，76，13，27，49）
      第一次交换   （27，38，65，97，76，13，49，49）
      第二次交换   （27，38，49，97，76，13，65，49）
      第三次交换   （27，38，13，97，76，49，65，49）
      第四次交换   （27，38，13，49，76，97，65，49）

      完成一趟排序
                 （[27，38，13]，49，[76，97，65，49]）

      再对        （27，38，13）（76，97，65，49）分别进行划分
      得到        （13，27，38 ）（49，65，76，97）
      最终完成     （13，27，38，49，49，54，76，97）



  代码：


     void QuickSort(int a[],int low, int high)
     {      
         if(low>=high)
         return;
         int i,j,base,temp;
         i=low,j=high;
         base=a[low];
         while(i<j)
         {
             while(a[j]>=base&&i<j)
             j--;
             while(a[i]<=base&&i<j)
             i++;
             if(i<j)
             {
                temp=a[i];
                a[i]=a[j];
                a[j]=temp;
             }
         }
         a[low]=a[i];
         a[i]=base;
         QuickSort(a,low,i-1);
         QuickSort(a,i+1,high);
     }


